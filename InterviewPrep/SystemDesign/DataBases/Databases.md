# Databases
## DB components
- There is a client (They do CRUD operations), and there is a Network layer which communicates with the database, after that there are components that work together for the DB to work.
- First component is a tokenizer, its like a lexer in a compiler, it checks if there are keywords used 
- Second component is a parser, its like a parser in a compiler, it checks if the query makes sense
- Next is optimizer, it changes the query and fixes it so its quicker. It outputs the execute file for the database to actually do
- These 3 components make up a database frontend
- Next component is a execution engine, its responsible for executing queries, which makes it the most important component in the database. Inside there is a cache management, which helps in seed. 
- Transaction manager is a component that checks if transactions have happened correctly. Acessing the database might be under a lock, and this component checks if everyhting runs correctly. If this component notices that something is done wrong, there must be a recovery manager that is able to fix things.
- Data needs to be stored on the disc, so there is a component that is called Storage Engine, which manages storaging data in a disc. For this, the db needs the buffer manager which is responsible for getting and putting back pages from the disc. Indexing is very importand for optimizing, and it has to do with storage and how stuff is stored, so there is an index manager that takes care of indexing
- There needs to be an interface for interaction with the OS. It communicates with OS and represents the DB. It is used so DB can be used on different operating systems
## Database structure
- Databases use B and B+ trees to store data. Its a special self balancing tree like structure. 
- File block on a disc is an intersection of a track and a sector on the disc. When someone wants to read/write something from the disk, They need to take the whole datablock from disc to ram. This is slow, and it is very useful when data sequential, because then its less moving from disc to ram and back. Because this is slow, there need to be optimization. This is where indexing comes in, and is used. Indexing is used with and index table, and is shown in the example:
- Lets say that there are 1 million records, and they need to be retrived from the disc because we want to find some data. Each page in the disc can store 10 records, which means that db will need 100k pages to store million records. To get the page from the disc to the ram it takes 1 millisecond. This means that if db want to get all the records, it will take 1 millisecond * 100k pages = 100 seconds to read all this data. Million records is not that much, and its unacceptable for reading it to be this slow. But lets say we introduce a table that has an entry that says the number of the page, and then a pointer to it. We know that we need 100k of these enteries, because we are using 100k pages to store 1 million records, and lets say that each entry is 10 bytes. This means that 400 of these can be stored in 1 page. That means that to store the whole index table, we need 100k entries / 400 per page = 250 pages to store the whole index table. Finding this table only takes 250*1 millisecond = 250 milliseconds. This is a lot faster then 100 seconds. Its possible to make this even smaller by making a tree structure from the index table. We would have a main table that points to other tables which actually contain pointer to the data we need. So lets say that the main table has 250 entries, and each points to a page where a part of the previous index table is stored. This first level table only takes 1 page, and then we take enteries from only a part of the second level index table which also takes 1 page, and then we retrive the data for that block. This means only 3 disc retrivals, which is 3 milliseconds of time, which is acceptably slow. This is the best concept for storing data and its called multi level indexing. This structure of index tables can be actually represented by a B tree, and thats why B tree is used in these cases.
-  There is a difference in B trees and B+ trees, not a big difference, ts that in B+ leafs al connected in a linked list, so its easier to visit sequential data. You only need to find the first element, and then you can traverse leafs through a linked list on leafs. Also B+ tree has keys in the internal nodes.

